from __future__ import annotations

import logging
from enum import IntFlag

import ida_name
from ida_idaapi import BADADDR, ea_t
from typing_extensions import TYPE_CHECKING, Iterator, Optional, Tuple, Union, cast

from .base import DatabaseEntity, InvalidEAError, check_db_open, decorate_all_methods, deprecated

if TYPE_CHECKING:
    from .database import Database

logger = logging.getLogger(__name__)


class SetNameFlags(IntFlag):
    """Flags for set_name() function."""

    CHECK = ida_name.SN_CHECK  # Fail if the name contains invalid characters
    NOCHECK = ida_name.SN_NOCHECK  # Replace invalid characters silently
    PUBLIC = ida_name.SN_PUBLIC  # Make name public
    NON_PUBLIC = ida_name.SN_NON_PUBLIC  # Make name non-public
    WEAK = ida_name.SN_WEAK  # Make name weak
    NON_WEAK = ida_name.SN_NON_WEAK  # Make name non-weak
    AUTO = ida_name.SN_AUTO  # Make name autogenerated
    NON_AUTO = ida_name.SN_NON_AUTO  # Make name non-autogenerated
    NOLIST = ida_name.SN_NOLIST  # Exclude name from the list
    NOWARN = ida_name.SN_NOWARN  # Don't display a warning if failed
    LOCAL = ida_name.SN_LOCAL  # Create local name
    IDBENC = ida_name.SN_IDBENC  # Name is given in IDB encoding
    FORCE = ida_name.SN_FORCE  # Try variations if name exists
    NODUMMY = ida_name.SN_NODUMMY  # Don't prepend with '_' for dummy suffixes
    DELTAIL = ida_name.SN_DELTAIL  # Delete hindering item if tail byte


class DemangleFlags(IntFlag):
    """Flags for demangling operations."""

    # Memory model mask (0x7)
    PTRMSK = ida_name.MNG_PTRMSK  # Memory model mask
    DEFNEAR = ida_name.MNG_DEFNEAR  # Inhibit near, display everything else
    DEFNEARANY = ida_name.MNG_DEFNEARANY  # Inhibit near/__ptr64, display everything else
    DEFFAR = ida_name.MNG_DEFFAR  # Inhibit far, display everything else
    NOPTRTYP16 = ida_name.MNG_NOPTRTYP16  # Inhibit everything (disables vc7-extensions)
    DEFHUGE = ida_name.MNG_DEFHUGE  # Inhibit huge, display everything else
    DEFPTR64 = ida_name.MNG_DEFPTR64  # Inhibit __ptr64, display everything else
    DEFNONE = ida_name.MNG_DEFNONE  # Display everything
    NOPTRTYP = ida_name.MNG_NOPTRTYP  # Inhibit everything

    # Name component inhibition flags
    NODEFINIT = ida_name.MNG_NODEFINIT  # Inhibit everything except the main name
    NOUNDERSCORE = ida_name.MNG_NOUNDERSCORE  # Inhibit underscores in __ccall, __pascal...
    NOTYPE = ida_name.MNG_NOTYPE  # Inhibit callc&based
    NORETTYPE = ida_name.MNG_NORETTYPE  # Inhibit return type of functions
    NOBASEDT = ida_name.MNG_NOBASEDT  # Inhibit base types
    NOCALLC = ida_name.MNG_NOCALLC  # Inhibit __pascal/__ccall/etc
    NOPOSTFC = ida_name.MNG_NOPOSTFC  # Inhibit postfix const
    NOSCTYP = ida_name.MNG_NOSCTYP  # Inhibit public/private/protected
    NOTHROW = ida_name.MNG_NOTHROW  # Inhibit throw description
    NOSTVIR = ida_name.MNG_NOSTVIR  # Inhibit "static" & "virtual"
    NOECSU = ida_name.MNG_NOECSU  # Inhibit class/struct/union/enum
    NOCSVOL = ida_name.MNG_NOCSVOL  # Inhibit const/volatile/restrict
    NOCLOSUR = ida_name.MNG_NOCLOSUR  # Inhibit __closure for borland
    NOUNALG = ida_name.MNG_NOUNALG  # Inhibit __unaligned
    NOMANAGE = ida_name.MNG_NOMANAGE  # Inhibit __pin/__box/__gc for ms(.net)
    NOMODULE = ida_name.MNG_NOMODULE  # Inhibit module names (Swift)

    # Format flags
    SHORT_S = ida_name.MNG_SHORT_S  # signed (int) is displayed as s(int)
    SHORT_U = ida_name.MNG_SHORT_U  # unsigned (int) is displayed as u(int)
    ZPT_SPACE = ida_name.MNG_ZPT_SPACE  # Display space after comma in the arglist
    DROP_IMP = ida_name.MNG_DROP_IMP  # Inhibit __declspec(dllimport)

    # Name processing flags
    IGN_ANYWAY = ida_name.MNG_IGN_ANYWAY  # Ignore '_nn' at the end of name
    IGN_JMP = ida_name.MNG_IGN_JMP  # Ignore 'j_' at the beginning of name
    MOVE_JMP = ida_name.MNG_MOVE_JMP  # Move 'j_' prefix to the demangled name

    # Compiler and composite flags
    COMPILER_MSK = ida_name.MNG_COMPILER_MSK  # Compiler mask (0-autodetect)
    SHORT_FORM = ida_name.MNG_SHORT_FORM  # Composite flag for short form
    LONG_FORM = ida_name.MNG_LONG_FORM  # Composite flag for long form
    CALC_VALID = ida_name.MNG_CALC_VALID  # Valid flags for calculation mode


@decorate_all_methods(check_db_open)
class Names(DatabaseEntity):
    """
    Provides access to symbol and label management in the IDA database.

    Can be used to iterate over all names in the opened database.

    Args:
        database: Reference to the active IDA database.
    """

    def __init__(self, database: Database) -> None:
        super().__init__(database)

    def __iter__(self) -> Iterator[Tuple[ea_t, str]]:
        return self.get_all()

    def __getitem__(self, index: int) -> Optional[Tuple[ea_t, str]]:
        return self.get_at_index(index)

    def __len__(self) -> int:
        """
        Returns the total number of named elements in the database.

        Returns:
            The number of named elements.
        """
        return self.get_count()

    def get_count(self) -> int:
        """
        Retrieves the total number of named elements in the database.

        Returns:
            The number of named elements.
        """
        return cast(int, ida_name.get_nlist_size())

    def get_at_index(self, index: int) -> Optional[Tuple[ea_t, str]]:
        """
        Retrieves the named element at the specified index.

        Args:
            index: Index of the named element to retrieve.

        Returns:
            A tuple (effective address, name) at the given index.
            In case of error, returns None.
        """
        if index >= 0 and index < ida_name.get_nlist_size():
            return ida_name.get_nlist_ea(index), ida_name.get_nlist_name(index)
        raise IndexError(f'Name index {index} out of range [0, {self.get_count()})')

    def get_at(self, ea: ea_t) -> Optional[str]:
        """
        Retrieves the name at the specified address.

        Args:
            ea: The effective address.

        Returns:
            The name string if it exists, None otherwise.

        Raises:
            InvalidEAError: If the effective address is invalid.
        """
        if not self.database.is_valid_ea(ea):
            raise InvalidEAError(ea)
        return cast(Optional[str], ida_name.get_name(ea))

    def get_all(self) -> Iterator[Tuple[ea_t, str]]:
        """
        Returns an iterator over all named elements in the database.

        Returns:
            An iterator over (address, name) tuples.
        """
        index = 0
        while index < ida_name.get_nlist_size():
            yield ida_name.get_nlist_ea(index), ida_name.get_nlist_name(index)
            index += 1

    def set_name(
        self, ea: ea_t, name: str, flags: Union[int, SetNameFlags] = SetNameFlags.NOCHECK
    ) -> bool:
        """
        Set or delete name of an item at the specified address.

        Args:
            ea: Linear address.
            name: New name. Empty string to delete name.
            flags: Set name flags (SetNameFlags enum or raw int).

        Returns:
            True if successful, False otherwise.

        Raises:
            InvalidEAError: If the effective address is invalid.
        """
        if not self.database.is_valid_ea(ea):
            raise InvalidEAError(ea)
        return cast(bool, ida_name.set_name(ea, name, flags))

    def force_name(
        self, ea: ea_t, name: str, flags: Union[int, SetNameFlags] = SetNameFlags.NOCHECK
    ) -> bool:
        """
        Force set a name, trying variations if the name already exists.

        Args:
            ea: Linear address.
            name: New name.
            flags: Set name flags (SetNameFlags enum or raw int).

        Returns:
            True if successful, False otherwise.

        Raises:
            InvalidEAError: If the effective address is invalid.
        """
        if not self.database.is_valid_ea(ea):
            raise InvalidEAError(ea)
        return cast(bool, ida_name.force_name(ea, name, flags))

    def delete_at(self, ea: ea_t) -> bool:
        """
        Delete name at the specified address.

        Args:
            ea: Linear address.

        Returns:
            True if successful, False otherwise.

        Raises:
            InvalidEAError: If the effective address is invalid.
        """
        if not self.database.is_valid_ea(ea):
            raise InvalidEAError(ea)
        return cast(bool, ida_name.del_global_name(ea))

    @deprecated("Use delete_at() instead")
    def delete(self, ea: ea_t) -> bool:
        """
        Delete name at the specified address.

        .. deprecated::
            Use :meth:`delete_at` instead.

        Args:
            ea: Linear address.

        Returns:
            True if successful, False otherwise.

        Raises:
            InvalidEAError: If the effective address is invalid.
        """
        return self.delete_at(ea)

    def is_valid_name(self, name: str) -> bool:
        """
        Check if a name is a valid user defined name.

        Args:
            name: Name to validate.

        Returns:
            True if valid, False otherwise.
        """
        return cast(bool, ida_name.is_uname(name))

    def is_public_name(self, ea: ea_t) -> bool:
        """
        Check if name at address is public.

        Args:
            ea: Linear address.

        Returns:
            True if public, False otherwise.

        Raises:
            InvalidEAError: If the effective address is invalid.
        """
        if not self.database.is_valid_ea(ea):
            raise InvalidEAError(ea)
        return cast(bool, ida_name.is_public_name(ea))

    def make_name_public(self, ea: ea_t) -> None:
        """
        Make name at address public.

        Args:
            ea: Linear address.

        Raises:
            InvalidEAError: If the effective address is invalid.
        """
        if not self.database.is_valid_ea(ea):
            raise InvalidEAError(ea)
        ida_name.make_name_public(ea)

    def make_name_non_public(self, ea: ea_t) -> None:
        """
        Make name at address non-public.

        Args:
            ea: Linear address.

        Raises:
            InvalidEAError: If the effective address is invalid.
        """
        if not self.database.is_valid_ea(ea):
            raise InvalidEAError(ea)
        ida_name.make_name_non_public(ea)

    def is_weak_name(self, ea: ea_t) -> bool:
        """
        Check if name at address is weak.

        Args:
            ea: Linear address.

        Returns:
            True if weak, False otherwise.

        Raises:
            InvalidEAError: If the effective address is invalid.
        """
        if not self.database.is_valid_ea(ea):
            raise InvalidEAError(ea)
        return cast(bool, ida_name.is_weak_name(ea))

    def make_name_weak(self, ea: ea_t) -> None:
        """
        Make name at address weak.

        Args:
            ea: Linear address.

        Raises:
            InvalidEAError: If the effective address is invalid.
        """
        if not self.database.is_valid_ea(ea):
            raise InvalidEAError(ea)
        ida_name.make_name_weak(ea)

    def make_name_non_weak(self, ea: ea_t) -> None:
        """
        Make name at address non-weak.

        Args:
            ea: Linear address.

        Raises:
            InvalidEAError: If the effective address is invalid.
        """
        if not self.database.is_valid_ea(ea):
            raise InvalidEAError(ea)
        ida_name.make_name_non_weak(ea)

    def get_demangled_name(
        self, ea: ea_t, inhibitor: Union[int, DemangleFlags] = 0, demform: int = 0
    ) -> Optional[str]:
        """
        Get demangled name at address.

        Args:
            ea: Linear address.
            inhibitor: Demangling inhibitor flags (DemangleFlags enum or raw int).
            demform: Demangling form flags.

        Returns:
            Demangled name or None if not available.

        Raises:
            InvalidEAError: If the effective address is invalid.
        """
        if not self.database.is_valid_ea(ea):
            raise InvalidEAError(ea)
        return cast(Optional[str], ida_name.get_demangled_name(ea, inhibitor, demform))

    def demangle_name(self, name: str, disable_mask: Union[int, DemangleFlags] = 0) -> str:
        """
        Demangle a mangled name.

        Args:
            name: Mangled name to demangle.
            disable_mask: Bits to inhibit parts of demangled name (DemangleFlags enum or raw int).

        Returns:
            Demangled name or original name if demangling failed.
        """
        return cast(str, ida_name.demangle_name(name, disable_mask))

    def resolve_name(self, name: str, from_ea: ea_t = BADADDR) -> Optional[ea_t]:
        """
        Resolve a name to its address.

        This method searches for a name in the database and returns its address.
        The search can be context-aware based on from_ea.

        Args:
            name: The name to resolve.
            from_ea: Context address for local name resolution. Defaults to BADADDR.

        Returns:
            The address of the name, or None if the name cannot be resolved.

        Example:
            >>> db = Database.open_current()
            >>> addr = db.names.resolve_name("main")
            >>> if addr:
            ...     print(f"main is at 0x{addr:x}")
        """
        ea = ida_name.get_name_ea(from_ea, name)
        # BADADDR is the invalid address marker
        if ea == BADADDR:
            return None
        return ea

    def resolve_value(self, name: str, from_ea: ea_t = BADADDR) -> Tuple[Optional[int], int]:
        """
        Get the numeric value and type of a name.

        The name can represent various things including regular addresses,
        enum constants, segment names, stack variables, etc. This method
        resolves the name and returns both its numeric value and type code.

        Args:
            name: Name to resolve.
            from_ea: Context address for resolution. Defaults to BADADDR.

        Returns:
            Tuple of (value, type_code) where:
            - value: The numeric value, or None if name has no value
            - type_code: One of the NT_* constants from ida_name (NT_NONE, NT_SEG,
              NT_FUNC, NT_STRUC, NT_ENUM, etc.)

        Example:
            >>> db = Database.open_current()
            >>> # Resolve an enum constant
            >>> value, name_type = db.names.resolve_value("MY_CONSTANT")
            >>> if name_type == ida_name.NT_ENUM:
            ...     print(f"Enum value: {value}")
            >>> # Resolve a function address
            >>> value, name_type = db.names.resolve_value("main")
            >>> if name_type == ida_name.NT_CODE:
            ...     print(f"Function at: 0x{value:x}")
        """
        # get_name_value returns a tuple (type, value) in IDA Python
        # The first element is the name type, the second is the value
        result = ida_name.get_name_value(from_ea, name)

        if result is None:
            return (None, ida_name.NT_NONE)

        name_type, value = result

        if name_type == ida_name.NT_NONE:
            return (None, name_type)

        return (int(value), name_type)

    def delete_local(self, ea: ea_t) -> bool:
        """
        Delete a local name at the specified address.

        Local names are scoped to functions and are not visible globally.

        Args:
            ea: Linear address.

        Returns:
            True if successful, False otherwise.

        Raises:
            InvalidEAError: If the effective address is invalid.

        Example:
            >>> db = Database.open_current()
            >>> # Delete a local label within a function
            >>> success = db.names.delete_local(0x401020)
        """
        if not self.database.is_valid_ea(ea):
            raise InvalidEAError(ea)
        return cast(bool, ida_name.del_local_name(ea))

    def create_dummy(self, from_ea: ea_t, ea: ea_t) -> bool:
        """
        Create an autogenerated dummy name at the specified address.

        Dummy names use special prefixes based on the item type:
        - loc_ for code labels
        - sub_ for functions
        - byte_, word_, dword_, qword_ for data
        - off_ for offsets
        - unk_ for unknown items

        Args:
            from_ea: Address of the operand that references the target.
            ea: Target address to name.

        Returns:
            True if successful, False otherwise.

        Raises:
            InvalidEAError: If either address is invalid.

        Example:
            >>> db = Database.open_current()
            >>> # Create dummy name for a jumped-to location
            >>> success = db.names.create_dummy(0x401000, 0x401050)
            >>> # This creates a name like "loc_401050"
        """
        if not self.database.is_valid_ea(from_ea):
            raise InvalidEAError(from_ea)
        if not self.database.is_valid_ea(ea):
            raise InvalidEAError(ea)
        return cast(bool, ida_name.set_dummy_name(from_ea, ea))

    def get_visible_name(self, ea: ea_t, local: bool = False) -> Optional[str]:
        """
        Get the visible name at an address.

        This returns the name that would be displayed in the disassembly,
        which may include function scope prefixes for local names.

        Args:
            ea: Linear address.
            local: If True, gets local name only, otherwise gets any visible name.

        Returns:
            The visible name, or None if no name exists.

        Raises:
            InvalidEAError: If the effective address is invalid.

        Example:
            >>> db = Database.open_current()
            >>> # Get the displayed name at an address
            >>> name = db.names.get_visible_name(0x401000)
            >>> print(f"Visible name: {name}")
        """
        if not self.database.is_valid_ea(ea):
            raise InvalidEAError(ea)

        # ida_name.get_name(ea) returns the name at an address
        # For local names, we'd need to use get_ea_name with flags
        # For simplicity, just return the standard name
        name = ida_name.get_name(ea)

        # If local flag is set and no name was found, that's expected
        # The local parameter is a hint but we can't easily distinguish
        # between local and global names with the simple API
        return cast(Optional[str], name)

    def validate(self, name: str, strict: bool = False) -> Tuple[bool, str]:
        """
        Validate a name and return validation result with cleaned name.

        This method checks if a name is valid according to IDA's naming rules
        and optionally returns a cleaned version of the name.

        Args:
            name: The name to validate.
            strict: If True, apply strict validation rules (currently unused).

        Returns:
            A tuple (is_valid, cleaned_name) where:
            - is_valid: True if the name is valid or can be made valid
            - cleaned_name: The original name if valid, or a cleaned version

        Example:
            >>> db = Database.open_current()
            >>> # Check if a name is valid
            >>> is_valid, cleaned = db.names.validate("my-function")
            >>> if is_valid:
            ...     print(f"Validated name: {cleaned}")
            >>> else:
            ...     print(f"Invalid name, suggested: {cleaned}")
        """
        # Check if it's already a valid user name
        if ida_name.is_uname(name):
            return (True, name)

        # Try to extract a valid name using IDA's validation
        # ida_name.validate_name() replaces invalid characters
        cleaned = ida_name.validate_name(name, ida_name.VNT_IDENT)

        if cleaned and ida_name.is_uname(cleaned):
            # validate_name returned a cleaned version
            return (True, cleaned)
        else:
            # Name cannot be made valid, return original with False
            return (False, name)

    def get_colored_name(self, ea: ea_t, local: bool = False) -> Optional[str]:
        """
        Get name with IDA color tags for syntax highlighting.

        This method returns the name at the specified address with color tags
        embedded in the string. Color tags are special sequences used by IDA's
        UI for syntax highlighting.

        Args:
            ea: Linear address.
            local: Try local names first if True.

        Returns:
            Colored name string with embedded color tags, or None if no name exists.

        Raises:
            InvalidEAError: If the effective address is invalid.

        Example:
            >>> db = Database.open_current()
            >>> # Get colored name for display
            >>> colored = db.names.get_colored_name(0x401000)
            >>> if colored:
            ...     print(f"Colored name: {colored}")
        """
        if not self.database.is_valid_ea(ea):
            raise InvalidEAError(ea)

        # Use get_colored_long_name which supports gtn_flags
        gtn_flags = ida_name.GN_LOCAL if local else 0
        name = ida_name.get_colored_long_name(ea, gtn_flags)
        return name if name else None

    def format_expression(
        self, from_ea: ea_t, n: int, ea: ea_t, offset: int, include_struct_fields: bool = True
    ) -> Optional[str]:
        """
        Convert address to name expression with displacement.

        This method formats an address as a symbolic name expression, optionally
        including offset displacement (e.g., "name+8") and structure field names.
        This is useful for displaying operand values symbolically.

        Args:
            from_ea: Address of instruction/operand that references the name.
            n: Operand number (0 for data items, 0-N for instruction operands).
            ea: Address to convert to a name expression.
            offset: The value the expression should represent (may differ from ea).
            include_struct_fields: Append struct member names if applicable.

        Returns:
            Formatted name expression like "name", "name+offset", or "name.field",
            or None on failure.

        Raises:
            InvalidEAError: If from_ea or ea is invalid.

        Example:
            >>> db = Database.open_current()
            >>> # Format an operand reference
            >>> expr = db.names.format_expression(
            ...     from_ea=0x401000,
            ...     n=1,
            ...     ea=0x405000,
            ...     offset=0x405008
            ... )
            >>> if expr:
            ...     print(f"Expression: {expr}")  # "data_405000+8" or similar
        """
        if not self.database.is_valid_ea(from_ea):
            raise InvalidEAError(from_ea)
        if not self.database.is_valid_ea(ea):
            raise InvalidEAError(ea)

        # GETN_APPZERO: append struct member names
        # GETN_NODUMMY: don't use dummy names for unknown offsets
        flags = ida_name.GETN_APPZERO if include_struct_fields else ida_name.GETN_NODUMMY

        # get_name_expr returns the formatted expression string
        result = ida_name.get_name_expr(from_ea, n, ea, offset, flags)

        return result if result else None
